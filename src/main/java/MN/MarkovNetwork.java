package MN;

import java.util.ArrayList;

public class MarkovNetwork {

	private ArrayList<Node> nodes;
	private ArrayList<Edge> edges;

	public MarkovNetwork() {
		// TODO: read in from file
		nodes = new ArrayList<Node>();
		edges = new ArrayList<Edge>();
	}
	
	public MarkovNetwork(ArrayList<Node> nodes, ArrayList<Edge> edges) {
		// TODO: for testing only
		this.nodes = nodes;
		this.edges = edges;
		
		System.out.println("Created our network!");
		print();
	}

	/**
	 * Use this to create the network structure (known) for the network
	 */
	private void createNetworkStructure() {
		// TODO: finish this

		// step 1: create nodes

		// step 2: create edges

		// each time an edge A-B is created, do: A.addNeighbor(B) and B.addNeighbor(A)
	}

	/**
	 * Returns the result of Gibbs sampling this distribution
	 * 
	 * @return
	 */
	public Sample sample() {
		
		Sample sample = new Sample(this);

		// 1) generate an initial sample (probably randomly from vals(Vars)
		for (Node n : nodes) {
			// chosen uniformly - does that work?
			double[] vals = n.getVals();
			double r = Math.random();
			double interval = (double) 1 / vals.length;
			
			int counter = 0;
			for (double i = interval; i <= 1; i += interval) {
				if (r < i) {
					sample.setSampledValue(n, vals[counter]);
					break;
				}
				counter++;
			}
		}
		
		System.out.println(" Initial sample: ");
		sample.print();
		
		// 2) For each non-evidence variable (so, all of them) [order
		// doesn't
		// matter]...
		for (Node N : nodes) {
			
			System.out.println(">>>>> Resampling Node " + N.getName());

			// 4) Calculate P(X|MB(X)) using current values for MB(X)
			ArrayList<Node> MB = N.getMB();			
			ArrayList<Edge> E = new ArrayList<Edge>();

			// Get all edges adjacent to N (there must be a better way to do
			// this)
			// TODO: refactor (if time)
			// (gives a more limited list to search later on)
			for (Edge e : edges) {
				if (e.getEndpoints().contains(N)) {
					E.add(e);
				}
			}

			// stores the distribution generated by calculations
			ProbDist probs = new ProbDist(N.getVals());

			// for each value of N
			double[] nVals = N.getVals();
			for (int n = 0; n < nVals.length; n++) {
				//System.out.println();
				//System.out.print("P~ (" + N.getName() + " == " + nVals[n] + ") \n");

				for (Node M : MB) {					
					Edge edge = null;
					// pull the edge between N and M
					for (Edge e : E) {
						if (e.getEndpoints().contains(M)) {
							edge = e;
						}
					}

					// get sample value of M
					double mVal = sample.getValue(M);

					// get potential where M=mVal and N=nVals[n]
					double p = edge.getPotential(N, nVals[n], M, mVal);
					//System.out.print(p + "[" +  M.getName() + " == " + mVal + "] *");

					// multiply current P(N==n) by p
					probs.setProb(nVals[n], probs.getProb(nVals[n]) * p);
				}
				
				//probs.print();

				// re-normalize
				probs.normalize();
				
				//probs.print();

				// re-sample resulting distribution for N
				sample.setSampledValue(N, probs.sample());
			}

		}
		
		// TODO: testing, remove
		System.out.println("\n Final sample: ");
		sample.print();
		
		return sample;
	}

	public ArrayList<Node> getNodes() {
		return nodes;
	}

	public void setNodes(ArrayList<Node> nodes) {
		this.nodes = nodes;
	}

	public ArrayList<Edge> getEdges() {
		return edges;
	}

	public void setEdges(ArrayList<Edge> edges) {
		this.edges = edges;
	}
	
	public void print(){
		System.out.println("NODES");
		for (int i = 0; i < nodes.size(); i++){
			System.out.println("> " + nodes.get(i).getName());
		}
		System.out.println("EDGES");
		for (int i = 0; i < edges.size(); i++){
			edges.get(i).printFactors();
		}
	}
}
