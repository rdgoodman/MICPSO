package MN;

import java.util.ArrayList;

public class MarkovNetwork {

	private ArrayList<Node> nodes;
	private ArrayList<Edge> edges;

	public MarkovNetwork() {
		// TODO: read in from file
		nodes = new ArrayList<Node>();
		edges = new ArrayList<Edge>();
	}

	/**
	 * Use this to create the network structure (known) for the network
	 */
	private void createNetworkStructure() {
		// TODO: finish this

		// step 1: create nodes

		// step 2: create edges

		// each time an edge A-B is created, do: A.addNeighbor(B) and B.addNeighbor(A)
	}

	/**
	 * Returns the result of Gibbs sampling this distribution
	 * 
	 * @return
	 */
	private Sample Sample() {

		Sample sample = new Sample(this);

		// 1) generate an initial sample (probably randomly from vals(Vars)
		for (Node n : nodes) {
			// TODO: chosen uniformly - does that work?
			double[] vals = n.getVals();
			double r = Math.random();
			double interval = 1 / vals.length;

			// TODO: holy guacamole, test this
			int counter = 0;
			for (double i = 0; i <= 1; i += interval) {
				if (r < i) {
					sample.setSampledValue(n, vals[counter]);
					break;
				}
				counter++;
			}
		}

		// 2) For each non-evidence variable (so, all of them) [order
		// doesn't
		// matter]...
		for (Node N : nodes) {

			// 4) Calculate P(X|MB(X)) using current values for MB(X)
			ArrayList<Node> MB = N.getMB();
			ArrayList<Edge> E = new ArrayList<Edge>();

			// Get all edges adjacent to N (there must be a better way to do
			// this)
			// TODO: refactor (if time)
			// (gives a more limited list to search later on)
			for (Edge e : edges) {
				if (e.getEndpoints().contains(N)) {
					E.add(e);
				}
			}

			// stores the distribution generated by calculations
			ProbDist probs = new ProbDist(N.getVals());

			// for each value of N
			double[] nVals = N.getVals();
			for (int n = 0; n < nVals.length; n++) {

				for (Node M : MB) {
					Edge edge = null;
					// pull the edge between N and M
					for (Edge e : E) {
						if (e.getEndpoints().contains(M)) {
							edge = e;
						}
					}

					// get sample value of M
					double mVal = sample.getValue(M);

					// get potential where M=mVal and N=nVals[n]
					double p = edge.getPotential(N, nVals[n], M, mVal);

					// multiply current P(N==n) by p
					probs.setProb(nVals[n], probs.getProb(nVals[n]) * p);
				}

				// re-normalize
				probs.normalize();

				// re-sample resulting distribution for N
				sample.setSampledValue(N, probs.sample());
			}

		}
		return sample;
	}

	public ArrayList<Node> getNodes() {
		return nodes;
	}

	public void setNodes(ArrayList<Node> nodes) {
		this.nodes = nodes;
	}

	public ArrayList<Edge> getEdges() {
		return edges;
	}

	public void setEdges(ArrayList<Edge> edges) {
		this.edges = edges;
	}
}
